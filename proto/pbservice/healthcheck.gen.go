// Code generated by mog. DO NOT EDIT.

package pbservice

import (
	"github.com/hashicorp/consul/agent/structs"
	"github.com/hashicorp/consul/proto/pbutil"
)

func CheckTypeToStructs(s CheckType) (structs.CheckType, error) {
	var t structs.CheckType
	t.CheckID = s.CheckID
	t.Name = s.Name
	t.Status = s.Status
	t.Notes = s.Notes
	t.ScriptArgs = s.ScriptArgs
	t.HTTP = s.HTTP
	t.H2PING = s.H2PING
	t.H2PingUseTLS = s.H2PingUseTLS
	t.Header = MapHeadersToStructs(s.Header)
	t.Method = s.Method
	t.Body = s.Body
	t.TCP = s.TCP
	interval, err := pbutil.DurationFromProto(&s.Interval)
	if err != nil {
		return t, err
	}
	t.Interval = interval

	t.AliasNode = s.AliasNode
	t.AliasService = s.AliasService
	t.DockerContainerID = s.DockerContainerID
	t.Shell = s.Shell
	t.GRPC = s.GRPC
	t.GRPCUseTLS = s.GRPCUseTLS
	t.TLSServerName = s.TLSServerName
	t.TLSSkipVerify = s.TLSSkipVerify
	timeout, err := pbutil.DurationFromProto(&s.Timeout)
	if err != nil {
		return t, err
	}
	t.Timeout = timeout
	ttl, err := pbutil.DurationFromProto(&s.TTL)
	if err != nil {
		return t, err
	}
	t.TTL = ttl
	t.SuccessBeforePassing = int(s.SuccessBeforePassing)
	t.FailuresBeforeCritical = int(s.FailuresBeforeCritical)
	t.FailuresBeforeWarning = int(s.FailuresBeforeWarning)
	t.ProxyHTTP = s.ProxyHTTP
	t.ProxyGRPC = s.ProxyGRPC
	deregisterCriticalServiceAfter, err := pbutil.DurationFromProto(&s.DeregisterCriticalServiceAfter)
	if err != nil {
		return t, err
	}
	t.DeregisterCriticalServiceAfter = deregisterCriticalServiceAfter
	t.OutputMaxSize = int(s.OutputMaxSize)
	return t, nil
}
func NewCheckTypeFromStructs(t structs.CheckType) CheckType {
	var s CheckType
	s.CheckID = t.CheckID
	s.Name = t.Name
	s.Status = t.Status
	s.Notes = t.Notes
	s.ScriptArgs = t.ScriptArgs
	s.HTTP = t.HTTP
	s.H2PING = t.H2PING
	s.H2PingUseTLS = t.H2PingUseTLS
	s.Header = NewMapHeadersFromStructs(t.Header)
	s.Method = t.Method
	s.Body = t.Body
	s.TCP = t.TCP
	s.Interval = *pbutil.DurationToProto(t.Interval)
	s.AliasNode = t.AliasNode
	s.AliasService = t.AliasService
	s.DockerContainerID = t.DockerContainerID
	s.Shell = t.Shell
	s.GRPC = t.GRPC
	s.GRPCUseTLS = t.GRPCUseTLS
	s.TLSServerName = t.TLSServerName
	s.TLSSkipVerify = t.TLSSkipVerify
	s.Timeout = *pbutil.DurationToProto(t.Timeout)
	s.TTL = *pbutil.DurationToProto(t.TTL)
	s.SuccessBeforePassing = int32(t.SuccessBeforePassing)
	s.FailuresBeforeCritical = int32(t.FailuresBeforeCritical)
	s.FailuresBeforeWarning = int32(t.FailuresBeforeWarning)
	s.ProxyHTTP = t.ProxyHTTP
	s.ProxyGRPC = t.ProxyGRPC
	s.DeregisterCriticalServiceAfter = *pbutil.DurationToProto(t.DeregisterCriticalServiceAfter)
	s.OutputMaxSize = int32(t.OutputMaxSize)
	return s
}
func HealthCheckToStructs(s HealthCheck) (structs.HealthCheck, error) {
	var t structs.HealthCheck
	t.Node = s.Node
	t.CheckID = s.CheckID
	t.Name = s.Name
	t.Status = s.Status
	t.Notes = s.Notes
	t.Output = s.Output
	t.ServiceID = s.ServiceID
	t.ServiceName = s.ServiceName
	t.ServiceTags = s.ServiceTags
	t.Type = s.Type
	t.ExposedPort = int(s.ExposedPort)
	definition, err := HealthCheckDefinitionToStructs(s.Definition)
	if err != nil {
		return t, err
	}
	t.Definition = definition
	t.EnterpriseMeta = EnterpriseMetaToStructs(s.EnterpriseMeta)
	t.RaftIndex = RaftIndexToStructs(s.RaftIndex)
	t.Interval = s.Interval
	t.Timeout = s.Timeout
	return t, nil
}
func NewHealthCheckFromStructs(t structs.HealthCheck) HealthCheck {
	var s HealthCheck
	s.Node = t.Node
	s.CheckID = t.CheckID
	s.Name = t.Name
	s.Status = t.Status
	s.Notes = t.Notes
	s.Output = t.Output
	s.ServiceID = t.ServiceID
	s.ServiceName = t.ServiceName
	s.ServiceTags = t.ServiceTags
	s.Type = t.Type
	s.ExposedPort = int32(t.ExposedPort)
	s.Definition = NewHealthCheckDefinitionFromStructs(t.Definition)
	s.EnterpriseMeta = NewEnterpriseMetaFromStructs(t.EnterpriseMeta)
	s.RaftIndex = NewRaftIndexFromStructs(t.RaftIndex)
	s.Interval = t.Interval
	s.Timeout = t.Timeout
	return s
}
func HealthCheckDefinitionToStructs(s HealthCheckDefinition) (structs.HealthCheckDefinition, error) {
	var t structs.HealthCheckDefinition
	t.HTTP = s.HTTP
	t.TLSServerName = s.TLSServerName
	t.TLSSkipVerify = s.TLSSkipVerify
	t.Header = MapHeadersToStructs(s.Header)
	t.Method = s.Method
	t.Body = s.Body
	t.TCP = s.TCP
	t.H2PING = s.H2PING
	t.H2PingUseTLS = s.H2PingUseTLS
	interval, err := pbutil.DurationFromProto(&s.Interval)
	if err != nil {
		return t, err
	}
	t.Interval = interval
	t.OutputMaxSize = uint(s.OutputMaxSize)
	timeout, err := pbutil.DurationFromProto(&s.Timeout)
	if err != nil {
		return t, err
	}
	t.Timeout = timeout
	deregisterCriticalServiceAfter, err := pbutil.DurationFromProto(&s.DeregisterCriticalServiceAfter)
	if err != nil {
		return t, err
	}
	t.DeregisterCriticalServiceAfter = deregisterCriticalServiceAfter
	t.ScriptArgs = s.ScriptArgs
	t.DockerContainerID = s.DockerContainerID
	t.Shell = s.Shell
	t.GRPC = s.GRPC
	t.GRPCUseTLS = s.GRPCUseTLS
	t.AliasNode = s.AliasNode
	t.AliasService = s.AliasService
	ttl, err := pbutil.DurationFromProto(&s.TTL)
	if err != nil {
		return t, err
	}
	t.TTL = ttl
	return t, nil
}
func NewHealthCheckDefinitionFromStructs(t structs.HealthCheckDefinition) HealthCheckDefinition {
	var s HealthCheckDefinition
	s.HTTP = t.HTTP
	s.TLSServerName = t.TLSServerName
	s.TLSSkipVerify = t.TLSSkipVerify
	s.Header = NewMapHeadersFromStructs(t.Header)
	s.Method = t.Method
	s.Body = t.Body
	s.TCP = t.TCP
	s.H2PING = t.H2PING
	s.H2PingUseTLS = t.H2PingUseTLS
	s.Interval = *pbutil.DurationToProto(t.Interval)
	s.OutputMaxSize = uint32(t.OutputMaxSize)
	s.Timeout = *pbutil.DurationToProto(t.Timeout)
	s.DeregisterCriticalServiceAfter = *pbutil.DurationToProto(t.DeregisterCriticalServiceAfter)
	s.ScriptArgs = t.ScriptArgs
	s.DockerContainerID = t.DockerContainerID
	s.Shell = t.Shell
	s.GRPC = t.GRPC
	s.GRPCUseTLS = t.GRPCUseTLS
	s.AliasNode = t.AliasNode
	s.AliasService = t.AliasService
	s.TTL = *pbutil.DurationToProto(t.TTL)
	return s
}
